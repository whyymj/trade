# LSTM 预测近似直线 — 原因分析

## 现象

前端「拟合曲线」中**预测涨跌幅**（`pred_mag`）几乎成一条水平直线，而**实际涨跌幅**（`actual_mag`）有明显波动。

## 原因分析

### 1. 回归目标 + MSE 导致“预测均值”（主因）

- **目标定义**：`y_magnitude` = 未来 5 日涨跌幅  
  `future_ret = (close[i+4] / close[i-1]) - 1`，典型范围约 **[-0.15, 0.15]**，均值接近 **0**。
- **损失**：回归头用 **MSE**。对这类目标，**恒预测均值**就能把 MSE 压得较低。
- **结果**：模型容易收敛到「对所有样本输出接近同一常数」（约等于训练集 `y_mag` 的均值），曲线看起来就像一条直线。

### 2. 双头联合训练，分类头主导梯度

- 损失：`loss = weight_cls * loss_cls + weight_reg * loss_reg`（默认均为 1.0）。
- 分类头（方向 0/1）更容易学、梯度大；回归头（小数值涨跌幅）相对难学、梯度小。
- 训练过程中**分类头占主导**，回归头更新不充分，更容易停留在「输出常数」的解。

### 3. 目标量纲小、未做缩放

- `y_magnitude` 是原始涨跌幅（如 0.02、-0.01），量纲小。
- 未对 `y_mag` 做标准化/缩放，全连接层初始输出若偏大或偏小，梯度相对弱，回归头更容易收敛到“安全”的常数预测。

### 4. 模型与训练配置偏保守

- **CPU 友好预设**：`hidden_size=32`、`epochs=25`、单层 LSTM。
- 容量和训练轮数有限时，模型可能只学到「方向」和「均值」，学不好涨跌幅的**幅度变化**，表现为 pred_mag 近似直线。

### 5. 时间序列被 Shuffle

- `DataLoader(..., shuffle=True)` 打乱了时间顺序。
- 对“用过去 60 日预测未来 5 日”的设定，shuffle 会削弱序列结构，不利于学到与时间相关的幅度模式，间接助长回归头预测常数。

---

## 改进建议（按优先级）

### 高优先级

1. **提高回归头权重**  
   例如 `weight_reg=2.0` 或更大，让回归头得到更多梯度，减少被分类头“压制”。

2. **对 y_magnitude 做标准化再训练**  
   - 训练时：用训练集均值、标准差标准化 `y_mag`，回归头预测标准化值。  
   - 预测/评估时：用同一均值、标准差反变换回涨跌幅。  
   便于网络学习、梯度更稳定，减少“只预测均值”的倾向。

3. **回归头使用 Huber 或 MAE**  
   用 `HuberLoss` 或 `L1Loss` 替代 MSE，对异常值更鲁棒，且不会像 MSE 那样强烈鼓励“预测均值”。

### 中优先级

4. **取消或减弱 Shuffle**  
   时间序列建议 `shuffle=False`，或仅做轻微 shuffle（如按块 shuffle），保留时间顺序。

5. **适当加大容量与训练**  
   若资源允许：增大 `hidden_size`（如 64/128）、适当增加 `epochs`，并观察验证集上 pred_mag 的方差是否增大。

6. **单独监控回归头**  
   训练时打印或记录「验证集上 pred_mag 的均值、标准差」，若标准差长期接近 0，说明仍在预测常数，需加强上述 1～3。

### 低优先级

7. **两阶段训练**  
   先固定分类头只训回归头若干 epoch，再联合微调，避免回归头一开始就被分类头压制。

8. **多步/分位数预测**  
   若业务需要，可增加分位数回归头（如预测 25%、50%、75% 分位），曲线会更有区分度，而不是单点估计。

---

## 小结

| 原因               | 说明 |
|--------------------|------|
| MSE + 小数值目标   | 最小化 MSE 易收敛到预测均值 → 直线 |
| 双头中分类主导     | 回归头梯度相对弱，易停滞在常数 |
| 目标未标准化       | 量纲小、梯度弱，利于“常数解” |
| 配置偏保守         | 容量/epoch 不足，幅度学不好 |
| Shuffle 破坏时序   | 不利于学到与时间相关的幅度 |

优先实施：**回归头权重加大**、**y_magnitude 标准化**、**回归损失改为 Huber/MAE**，并**关闭或减弱 shuffle**，再观察「预测涨跌幅」曲线是否开始跟随实际波动。

---

## 其他可选的优化方向

| 方法 | 说明 |
|------|------|
| **reg_loss_type="full_huber"** | 主项用 Huber 替代 MSE，减轻对「预测均值」的偏好，训练时传 `reg_loss_type: "full_huber"` 即可。 |
| **两阶段训练** | 先冻结分类头、只训回归头若干 epoch，再解冻联合微调，避免回归头一开始被分类头压制（需改训练流程）。 |
| **回归头更大学习率** | 对 magnitude 相关参数单独设更高 lr（如 2×），需在优化器里用 parameter groups。 |
| **适当加大容量** | 若资源允许，可试更大 `hidden_size` 或更多层，给幅度学习更多表达能力。 |
| **验证集监控** | 训练时记录验证集上 pred_mag 的 std，若长期接近 0 说明仍在预测常数。 |

---

## 诊断功能如何使用

项目内置了「预测平淡」诊断，可从**前端**或**Python** 使用。

### 方式一：前端（拟合图下方）

1. 打开 LSTM 页面，选择股票与年限（1/2/3 年）。
2. 若该模型存在「波动率过低、模型过小、特征相关性低、损失过低」等问题，**拟合曲线图上方**会显示黄色诊断条，列出具体原因。
3. 无问题时不会显示诊断条。

数据来源：接口 `GET /api/lstm/plot-data?symbol=xxx&years=1` 的返回里，在有问题时包含 `diagnostics` 对象（键为问题类型，值为说明文案）。

### 方式二：Python 中直接调用

在训练或评估后，用当前模型的预测值、实际值、模型和训练数据做一次诊断：

```python
from analysis.lstm_diagnostics import 诊断LSTM预测平淡问题, 计算特征相关性

# 假设已有：model, X, y_mag，以及模型对 X 的预测 pred_mag
pred_mag = ...   # 模型输出的涨跌幅预测，一维
y_mag = ...      # 真实涨跌幅，与 pred_mag 等长
训练数据 = {
    "X": X,                          # (n, seq_len, n_features)
    "训练损失": [0.5, 0.2, 0.08],     # 可选：每轮训练损失
}
诊断结果 = 诊断LSTM预测平淡问题(pred_mag, y_mag, model, 训练数据)

# 仅包含“有问题”的项
for 问题类型, 说明 in 诊断结果.items():
    print(f"[{问题类型}] {说明}")
```

若只需看**特征与目标的相关性**（不跑完整诊断）：

```python
from analysis.lstm_diagnostics import 计算特征相关性
import numpy as np

# 特征 (n_samples, seq_len, n_features)，实际值 (n_samples,)
相关性 = 计算特征相关性(X, y_mag)
print("各特征与涨跌幅相关系数:", 相关性)
print("平均绝对值:", np.mean(np.abs(相关性)))
```
